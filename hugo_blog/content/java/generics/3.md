+++
title = "java generics ë²ˆì—­ 3"
description = "ìë°” ì œë„¤ë¦­ìŠ¤(java generics) ë²ˆì—­"
author = "durtchrt"
tags = [ "java", "generics" ]
date = "2016-10-31T17:08:57+09:00"

+++

Generic Types

generic typeì€ ì¼ë°˜ì ì¸ í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤ë¥¼ íƒ€ì… íŒŒë¼ë¯¸í„°í™”í•˜ëŠ” ê²ƒì´ë‹¤. Box í´ë˜ìŠ¤ëŠ” ê°œë…ì„ ì¦ëª…í•˜ë©° ì½”ë“œê°€ ë³€ê²½ë˜ì–´ì§ˆ ê²ƒì…ë‹ˆë‹¤.
`A generic type is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.`

A Simple Box Class

genericì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì˜ˆì œë¡œ ì‹œì‘í•´ë´…ì‹œë‹¤. Box í´ë˜ìŠ¤ëŠ” ëª¨ë“  íƒ€ì…ì˜ objectì—ì„œ ë™ì‘í•©ë‹ˆë‹¤. Box í´ë˜ìŠ¤ëŠ” set(ì¶”ê°€), get(ì¡°íšŒ) 2ê°œì˜ ë©”ì„œë“œê°€ ìˆìŠµë‹ˆë‹¤.
`Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:`

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```
ê°ì²´ì˜ set, get ë©”ì„œë“œëŠ” ê¸°ë³¸í˜•ì„ ì œì™¸í•˜ë©´ ì–´ë–¤ íƒ€ì…(ì°¸ì¡°í˜•)ì´ë“  ì¸ìë¡œ ë„£ì„ìˆ˜ ìˆë‹¤. Box í´ë˜ìŠ¤ê°€ ì‚¬ìš©ë˜ì–´ì§€ì§€ë§Œ ì»´íŒŒì¼ íƒ€ì„ì— ê²€ì¦í•  ë°©ë²•ì´ ì—†ë‹¤. ì½”ë“œì˜ í•œíŒŒíŠ¸ì—ì„œëŠ” Integerë¥¼ ë„£ê³  Integerê°€ returnë˜ì–´ì§€ê¸¸ ê¸°ëŒ€í•˜ì§€ë§Œ ë‹¤ë¥¸ í•œìª½ ì½”ë“œì—ì„œëŠ” ì‹¤ìˆ˜ë¡œ Stringì„ ì…ë ¥í•´ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë‚˜ì˜¬ ê²ƒì…ë‹ˆë‹¤.
`Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.`


Generic ë²„ì „ì˜ Box í´ë˜ìŠ¤.<br>
`A Generic Version of the Box Class`

generic í´ë˜ì‹œëŠ” ì•„ë˜ í¬ë©§ì²˜ëŸ¼ ì •ì˜ë˜ì—ˆë‹¤.<br>
`A generic class is defined with the following format:`

```java
class name<T1, T2, ..., Tn> { /* ... */ }
```

íƒ€ì… íŒŒë¼ë¯¸í„° ë¬¸ë²•ì€ í´ë˜ìŠ¤ëª… ë’¤ì— êº½ì‡ (<>) ê¸°í˜¸ë¡œ êµ¬ë¶„ëœë‹¤. ì´ê²ƒì€ T1, T2, ..., and Tn ë“±ìœ¼ë¡œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ëª…ì‹œí•œë‹¤.(íƒ€ì…ë³€ìˆ˜ë¼ê³  ë¶ˆë¦¬ê¸°ë„í•œë‹¤.) . 
`The type parameter section, delimited by angle brackets (<>), follows the class name. It specifies the type parameters (also called type variables) T1, T2, ..., and Tn.`

Box í´ë˜ìŠ¤ë¥¼ genericsë¡œ ë³€ê²½í•´ë³´ì. "public class Box" ì½”ë“œë¥¼ "public class Box<T>"ë¡œ ë³€ê²½í•´ì„œ generic íƒ€ì…ì„ ì„ ì–¸í•˜ì—¬ ìƒì„±í•œë‹¤. Të¼ëŠ” íƒ€ì… ë³€ìˆ˜ë¥¼ ë§í•˜ìë©´ í´ë˜ìŠ¤ ì•ˆ ì–´ë””ë“ ì§€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜ì´ë‹¤.
`To update the Box class to use generics, you create a generic type declaration by changing the code "public class Box" to "public class Box<T>". This introduces the type variable, T, that can be used anywhere inside the class.`

Box í´ë˜ìŠ¤ê°€ ì´ë ‡ê²Œ ë°”ë€ë‹ˆë‹¤.<br>
`With this change, the Box class becomes:`
```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

ì†ŒìŠ¤ ì½”ë“œ ë³€ê²½ì—ì„œ ë³´ì´ë“¯ì´, ê¸°ì¡´ ì½”ë“œì—ì„œ Object ëŒ€ì‹  Të¡œ ìˆ˜ì •ë˜ì—ˆë‹¤. Type ë³€ìˆ˜ëŠ” ê¸°ë³¸í˜• ë¹¼ê³ ëŠ”(=ì°¸ì¡°í˜•)ì´ë©´ ëœë‹¤.(í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤/ë°°ì—´ íƒ€ì… ë˜ëŠ” ë‹¤ë¥¸ Type ë³€ìˆ˜ê°€ Type ë³€ìˆ˜ë¡œ ë  ìˆ˜ ìˆë‹¤.)
`As you can see, all occurrences of Object are replaced by T. A type variable can be any non-primitive type you specify: any class type, any interface type, any array type, or even another type variable.`

generic ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ë„ ê°™ë‹¤.<br>
'This same technique can be applied to create generic interfaces.'

Type íŒŒë¼ë¯¸í„° ë„¤ì´ë° ê´€ìŠµ<br>
`Type Parameter Naming Conventions`

ê´€ìŠµì— ì˜í•˜ë©´, Type íŒŒë¼ë¯¸í„°ëŠ” ë‹¨ì¼ ëŒ€ë¬¸ìì…ë‹ˆë‹¤. ì´ ê¸°ì¤€ì€ ì´ë¯¸ ì•Œê³  ìˆëŠ” ë³€ìˆ˜ ë„¤ì´ë° ê´€ìŠµì— ê·¹ëª…í•˜ê²Œ ë°˜ëŒ€ì…ë‹ˆë‹¤. (ì¢‹ì€ì ì€)ì´ëŸ° ê´€ìŠµì´ ì—†ìœ¼ë©´ Type ë³€ìˆ˜ì™€ ì¼ë°˜ì ì¸ í´ë˜ìŠ¤ í˜¹ì€ ì¸í„°í˜ì´ìŠ¤ëª… ì‚¬ì´ì— ì°¨ì´ë¥¼ ì „ë‹¬í•˜ê¸° ì–´ë µìš¸ê²ë‹ˆë‹¤.
`By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.`

ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì–´ì§€ëŠ” TypeíŒŒë¼ë©”í„°ëª…ì…ë‹ˆë‹¤.<br>
`The most commonly used type parameter names are:`

E - Element (used extensively by the Java Collections Framework)
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types
You'll see these names used throughout the Java SE API and the rest of this lesson.

Invoking and Instantiating a Generic Type

To reference the generic Box class from within your code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:

Box<Integer> integerBox;
You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a type argument â€” Integer in this case â€” to the Box class itself.

Type Parameter and Type Argument Terminology: Many developers use the terms "type parameter" and "type argument" interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in Foo<T> is a type parameter and the String in Foo<String> f is a type argument. This lesson observes this definition when using these terms.
Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a "Box of Integer", which is how Box<Integer> is read.

An invocation of a generic type is generally known as a parameterized type.

To instantiate this class, use the new keyword, as usual, but place <Integer> between the class name and the parenthesis:

Box<Integer> integerBox = new Box<Integer>();
The Diamond

In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (<>) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, <>, is informally called the diamond. For example, you can create an instance of Box<Integer> with the following statement:

Box<Integer> integerBox = new Box<>();
For more information on diamond notation and type inference, see Type Inference.

Multiple Type Parameters

As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:

public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
The following statements create two instantiations of the OrderedPair class:

Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");
The code, new OrderedPair<String, Integer>, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair's constructor are String and Integer, respectively. Due to autoboxing, it is valid to pass a String and an int to the class.

As mentioned in The Diamond, because a Java compiler can infer the K and V types from the declaration OrderedPair<String, Integer>, these statements can be shortened using diamond notation:

OrderedPair<String, Integer> p1 = new OrderedPair<>("Even", 8);
OrderedPair<String, String>  p2 = new OrderedPair<>("hello", "world");
To create a generic interface, follow the same conventions as for creating a generic class.

Parameterized Types

You can also substitute a type parameter (i.e., K or V) with a parameterized type (i.e., List<String>). For example, using the OrderedPair<K, V> example:

OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));