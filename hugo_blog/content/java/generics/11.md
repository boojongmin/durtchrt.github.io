+++
title = "ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Wildcards "
description = "ìë°” ì œë„¤ë¦­ìŠ¤(10) ì™€ì¼ë“œì¹´ë“œ Whildcards"
author = "durtchrt"
tags = [ "java", "generics"  ]
date = "2016-11-12T18:23:01+09:00"

+++
### ìƒìœ„ ì œí•œëœ ì™€ì¼ë“œ ì¹´ë“œ `Upper Bounded Wildcards`

ë³€ìˆ˜ì— ì™„í™”ëœ ì œí•œì„ ê±¸ê³  ì‹¶ì„ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•œë‹¤. ì˜ˆë¥¼ë“¤ë©´, List\<Integer\>, List\<Double\>, List\<Number\> íƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í• ë•Œ upper bounded wildcardë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ ìˆë‹¤.
`You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on List<Integer>, List<Double>, and List<Number>; you can achieve this by using an upper bounded wildcard.`

uppper-bounded wildcardëŠ” ì™€ì¼ë“œì¹´ë“œ ë¬¸ì '?'ì™€ ë’¤ì—ëŠ” extends í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ê³  ë’¤ì—ëŠ” ìƒìœ„ íƒ€ì…ì„ ì¨ì„œ ì •ì˜í•œë‹¤. í´ë˜ìŠ¤ì˜ extends, ì¸í„°í˜ì´ìŠ¤ì˜ implementsì²˜ëŸ¼ extends í‚¤ì›Œë“œëŠ” ì´ëŸ¬í•œ ì˜ë¯¸ë¡œ ì‚¬ìš©ëœë‹¤.
`To declare an upper-bounded wildcard, use the wildcard character ('?'), followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either "extends" (as in classes) or "implements" (as in interfaces).`

Integer, Double, Floatì²˜ëŸ¼ Number íƒ€ì…ì˜ ì„œë¸Œíƒ€ì…ë“¤ì—ì„œ ë™ì‘í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•  ë•Œ, List\<? extends Number\> ìš”ë˜ ì‘ì„±í•˜ë©´ëœë‹¤. List\<Number\>ëŠ” List\<? extends Number\>ë³´ë‹¤ ì œí•œì ì´ë‹¤. ì „ìëŠ” Number íƒ€ì…ì˜ ë¦¬ìŠ¤íŠ¸ë§Œ ê°€ëŠ¥, í›„ìëŠ” Number íƒ€ì… ë˜ëŠ” Number íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì… ë¦¬ìŠ¤íŠ¸ë„ ê°€ëŠ¥í•˜ë‹¤.
`To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List<? extends Number>. The term List<Number> is more restrictive than List<? extends Number> because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.`

ì•„ë˜ì˜ process ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì `Consider the following process method:`

```java
public static void process(List<? extends Foo> list) { /* ... */ }
```

\<? extends Foo\> upper bounded wildcardëŠ” Fooì™€ Fooì˜ ì„œë¸Œíƒ€ì…ê³¼ ë§¤ì¹˜ë˜ëŠ” í‘œí˜„ì´ë‹¤. (ì•„ë˜ì˜ ì½”ë“œ ì°¸ì¡°)process ë©”ì„œë“œëŠ” Fooíƒ€ì…ê³¼ ê°™ì€ ë¦¬ìŠ¤íŠ¸ì˜ ìš”ì†Œë¥¼ ì—‘ì„¸ìŠ¤í• ìˆ˜ ìˆë‹¤.
`The upper bounded wildcard, <? extends Foo>, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:`

```java
public static void process(List<? extends Foo> list) {
    for (Foo elem : list) {
        // ...
    }
}
```

foreachì ˆì€ listì˜ ê°ê° ìš”ì†Œë¥¼ ìˆœíšŒí•˜ë©° elem ë³€ìˆ˜ì— í• ë‹¹í•œë‹¤.  elemì€ Foo í´ë˜ìŠ¤ì— ì •ì˜ë˜ì–´ ìˆëŠ” ë©”ì„œë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
`In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.`

sumOfListë©”ì„œë“œëŠ” ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ìˆ«ìì˜ í•©ì„ ë¦¬í„´í•œë‹¤. `The sumOfList method returns the sum of the numbers in a list:`

```java
public static double sumOfList(List<? extends Number> list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
```
ì•„ë˜ì˜ ì½”ë“œëŠ” Integer ê°ì²´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ "sum = 6.0"ì„ ì¶œë ¥í•œë‹¤.
`The following code, using a list of Integer objects, prints sum = 6.0:`

```java
List<Integer> li = Arrays.asList(1, 2, 3);
System.out.println("sum = " + sumOfList(li));
```

Doubleê°’ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë„ sumOfList ë©”ì„œë“œë¥¼ ì—­ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ì˜ ì½”ë“œëŠ” "sum = 7.0"ì„ ì¶œë ¥í•œë‹¤.
`A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:`

```java
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println("sum = " + sumOfList(ld));
```














